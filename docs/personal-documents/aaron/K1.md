# K1
In blok 4 heb ik veel objectgeoriënteerde code geschreven die samenwerkt met een database. We maken gebruik van een ORM in Spring Boot om de database aan te maken. Een voorbeeld van een model kun je [hier](https://gitlab.fdmci.hva.nl/propedeuse-hbo-ict/onderwijs/2023-2024/out-b-se-bim/blok-4/caaruujuuwoo65/-/blob/feature/frontend-authentication/project/backend/src/main/java/caaruujuuwoo65/backend/model/User.java?ref_type=heads) vinden. In dit model maak ik ook gebruik van encapsulation en inheritance. Verder maken we gebruik van JPA repositories om de data uit de database op te halen en te bewerken.

In de volgende bestanden laten we zien hoe verschillende principes van object-georiënteerd programmeren (OOP) worden toegepast bij het maken van component van lit. Hierbij gebruiken we de onderstaande drie bestanden als referentie:

1. [LoginComponent.ts](https://gitlab.fdmci.hva.nl/propedeuse-hbo-ict/onderwijs/2023-2024/out-b-se-bim/blok-4/caaruujuuwoo65/-/blob/feature/frontend-authentication/project/frontend/src/components/views/loginPage/loginComponent.ts?ref_type=heads)
2. [RegisterComponent.ts](https://gitlab.fdmci.hva.nl/propedeuse-hbo-ict/onderwijs/2023-2024/out-b-se-bim/blok-4/caaruujuuwoo65/-/blob/feature/frontend-authentication/project/frontend/src/components/views/registerPage/RegisterComponent.ts?ref_type=heads)
3. [BaseAuthComponent.ts](https://gitlab.fdmci.hva.nl/propedeuse-hbo-ict/onderwijs/2023-2024/out-b-se-bim/blok-4/caaruujuuwoo65/-/blob/feature/frontend-authentication/project/frontend/src/components/BaseAuthComponent.ts?ref_type=heads)

## Encapsulation
### Voorbeeld

In `BaseAuthComponent.ts` worden methoden en eigenschappen beschermd door ze `protected` of `private` te maken. Dit zorgt ervoor dat ze alleen toegankelijk zijn binnen de klasse zelf en door afgeleide klassen, en niet door externe code.

```typescript
@property({ type: String }) public email = "";
@property({ type: String }) public password = "";

protected updateField(field: Field, e: Event): void {
    this[field] = (e.target as HTMLInputElement).value;
}

private handlePasswordInput(e: Event): void {
    this.password = (e.target as HTMLInputElement).value;
    this.passwordStrength = this.getPasswordStrength(this.password);
}
```

Hier wordt `updateField` beschermd zodat het alleen binnen de component en zijn subklassen kan worden gebruikt, terwijl `handlePasswordInput` prive is en alleen binnen de class zelf kan worden gebruikt.

## Inheritance
### Voorbeeld

De `LoginComponent` en `RegisterComponent` erven beide van de `BaseAuthComponent`. Hierdoor kunnen ze gemeenschappelijke functionaliteit delen en specifieke implementaties toevoegen waar nodig.

```typescript
@customElement("login-component")
export class LoginComponent extends BaseAuthComponent {
    
}

@customElement("register-component")
export class RegisterComponent extends BaseAuthComponent {
    
}
```

## Polymorphism
### Voorbeeld

In `BaseAuthComponent` is `handleSubmit` gedefinieerd als een abstracte methode, wat betekent dat elke subklasse deze methode moet implementeren.

```typescript
protected abstract handleSubmit(e: Event): void;
```

In zowel `LoginComponent` als `RegisterComponent` wordt `handleSubmit` geimplementeerd om specifieke logica toe te voegen voor het inloggen en registreren.

```typescript
@customElement("login-component")
export class LoginComponent extends BaseAuthComponent {
    protected async handleSubmit(e: Event): Promise<void> {
    }
}

@customElement("register-component")
export class RegisterComponent extends BaseAuthComponent {
    protected async handleSubmit(e: Event): Promise<void> {
    }
}
```

## Abstraction
### Voorbeeld

In `BaseAuthComponent` definieren we een abstracte methode `handleSubmit`. Dit betekent dat de specifieke implementatie van `handleSubmit` wordt overgelaten aan de subklassen, terwijl de algemene structuur en contract behouden blijven.

```typescript
export abstract class BaseAuthComponent extends LitElement {
    @property({ type: String }) public email = "";
    @property({ type: String }) public password = "";
    @property({ type: String }) public error = "";
    
    protected abstract handleSubmit(e: Event): void;
}
```

In `LoginComponent` en `RegisterComponent` implementeren we de abstracte methode `handleSubmit` met specifieke logica voor inloggen en registreren respectief.

```typescript
@customElement("login-component")
export class LoginComponent extends BaseAuthComponent {
    protected async handleSubmit(e: Event): Promise<void> {
        e.preventDefault();
        const userService: UserService = new UserService();
        const response: UserAuthResponse = await userService.login({ email: this.email, password: this.password });

        if (response.success) {
            document.location.pathname = "/home";
        } else {
            this.error = response.message;
        }
    }
}

@customElement("register-component")
export class RegisterComponent extends BaseAuthComponent {
    protected async handleSubmit(e: Event): Promise<void> {
        e.preventDefault();
        if (this.password === this.confirmPassword) {
            this.error = "";
        } else {
            this.error = "Passwords do not match";
            return;
        }

        const user: UserRegisterFormModel = {
            username: this.username,
            email: this.email,
            phoneNumber: this.phoneNumber,
            firstname: this.firstname,
            lastname: this.lastname,
            password: this.password
        };

        const userService: UserService = new UserService();
        const response: UserAuthResponse = await userService.register(user);

        if (response.success) {
            document.location.pathname = "/home";
        } else {
            this.error = response.message;
        }
    }
}
```

## Generics
### Voorbeeld

Hier definiëren we `createInput` met een generiek type `T` dat beperkt is tot de waarden van `Field`.

```typescript
type Field = "email" | "password" | "username" | "phoneNumber" | "firstname" | "lastname" | "confirmPassword";

protected createInput<T extends Field>(type: string, value: string, field: T, placeholder: string): TemplateResult {
    return html`
        <input class="form-input" required type="${type}" .value="${value}" @input="${(e: Event): void => this.updateField(field, e)}" placeholder="${placeholder}">
    `;
}

protected updateField<T extends Field>(field: T, e: Event): void {
    this[field] = (e.target as HTMLInputElement).value;
}
```

Hierdoor kunnen we `createInput` aanroepen met elke `Field` en zorgt TypeScript ervoor dat de juiste types worden gebruikt. Dit maakt het een stuk meer 'typesafe'

## Links
- [User model](https://gitlab.fdmci.hva.nl/propedeuse-hbo-ict/onderwijs/2023-2024/out-b-se-bim/blok-4/caaruujuuwoo65/-/blob/feature/frontend-authentication/project/backend/src/main/java/caaruujuuwoo65/backend/model/User.java?ref_type=heads)
- [LoginComponent.ts](https://gitlab.fdmci.hva.nl/propedeuse-hbo-ict/onderwijs/2023-2024/out-b-se-bim/blok-4/caaruujuuwoo65/-/blob/feature/frontend-authentication/project/frontend/src/components/views/loginPage/loginComponent.ts?ref_type=heads)
- [RegisterComponent.ts](https://gitlab.fdmci.hva.nl/propedeuse-hbo-ict/onderwijs/2023-2024/out-b-se-bim/blok-4/caaruujuuwoo65/-/blob/feature/frontend-authentication/project/frontend/src/components/views/registerPage/RegisterComponent.ts?ref_type=heads)
- [BaseAuthComponent.ts](https://gitlab.fdmci.hva.nl/propedeuse-hbo-ict/onderwijs/2023-2024/out-b-se-bim/blok-4/caaruujuuwoo65/-/blob/feature/frontend-authentication/project/frontend/src/components/BaseAuthComponent.ts?ref_type=heads)
